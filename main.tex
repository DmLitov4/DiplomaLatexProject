% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}


\NewBibliographyString{langjapanese}
\NewBibliographyString{fromjapanese}

\begin{document}

\Intro

Рекомендательные системы стали неотъемлемой частью пользовательских приложений и сервисов, получили широкое распространение в последнее время. Рекомендательные системы - это программы и сервисы, которые пытаются определить, что нужно в данный момент времени пользователю, и предоставить ему это (или порекомендовать, откуда и произошло название). Объекты, которые рекомендуются, могут быть различны, это зависит от характера системы. Чаще всего такими объектами, находящимися в центре внимания подобных сервисов, становятся книги, фильмы, музыка, новости или веб-сайты.

Два главных подхода, которые используются в любых рекомендательных системах - это контентная и коллабортивная фильтрации. Трактовки данных понятий столь же различны, сколько и подходы к их реализации. Контетная фильтрация - это рекомендательная система, основанная на контенте, хранящемся в данных системы, и его характеристиках, свойствах, параметрах. Коллаборативная фильтрация - это рекомендательная система, опирающаяся на поведение пользователя в прошлом (информация о покупках или оценках) и поведение похожих на него пользователей. Здесь не имеет значения, с какими объектами происходит работа, но при этом могут учитываться и неявные характеристики.

Во время работы рекомендательные системы собирают данные о пользователях, при этом используется сочетание явных и неявных методов. Явный сбор данных осуществляется с помощью запроса у пользователя оценки объекта по данной шкале, 
предъявления пользователю двух объектов с вопросом о том, какой из них лучше,
предложения создать список объектов, которые нравятся пользователю. Неявный сбор данных происходит с помощью наблюдения за тем, что просматривает пользователь, ведения записей о поведении пользователя в сети, отслеживание содержимого компьютера пользователя. Впрочем, используются и другие способы.


% Если typeOfWork в SETUP.tex задан как 2 или 3, то начинать
% надо не с section (раздел), а с главы (chapter)
\section{Постановка задачи}
\label{sec:examples}

Основной целью данной работы стала реализация общедоступного во всемирной сети рекомендательного веб-сервиса кафе и ресторанов в городе Ростове-на-Дону. Данная задча повлекла за собой исследование новейших подходов к решению известных проблем и задач, возникающих при реализации рекомендательных веб-систем, а также создание собственных методов обработки информации и анализа данных.

Важным требованием к данному веб-сервису на этапе постановки задачи являлось присутствие контентной и коллаборативной фильтраций, а также комбинирование явных и неявных методов сбора данных. При этом было немаловажно наличие личного кабинета пользователя, релевантной базы данных объектов для просмотра и рекомендаций, интуитивно понятного и современного интерфейса пользователя, который адаптивно подстаивается под стационарные и мобильные устройства. Отличительной особенностью данного сервиса от уже существующих предполагается новый способ решения классической проблемы холодного старта системы с помощью сбора, анализа и кластеризации данных, полученных неявно с помощью актуальных данных из социальных сетей.

Таким образом, на этапе постановки задачи были изучены существующие сервисы, предоставляющие возможности рекомендательных систем. Были рассмотрены как крупные сервисы (Amazon, Netflix, IMDB и другие), так и менее значимые региональные системы (IVI, Кинопоиск и другие). Также был произведен поиск старых и новых опубликованных статей по данной тематике. В процессе работы были изучены различные варианты пользовательских интерфейсов для предоставления рекомендаций, доступные методы сбора и обработки данных разных пользователей и различные проблемы. Так были выявлены слабые места таких систем, что дало возможность исследовать их более детально, найти новые способы улучшения, получить результаты и сравнить их недостатки и преимущества с уже существующими системами.


\section{Программный интерфейс пользователя}
\label{sec:examples}

Рекомендательная система, описанная в данной работе, представляет из себя веб-сервис, который был запущен на локальном сервере разрабочика в период разработки и отладки, а затем опубликован на общедоступном бесплатном сервере Pythonanywhere.

Таким образом, пользовательский интерфейс представляет собой набор HTML-страниц с динамическим содержимым, которые логически разделены между собой. Отображение некоторых данных на стороне пользователя и некоторые элементы интерфейса формируются при помощи скриптов языка JavaScript (и, в частности библиотеки JQuery), а также таблицы стилей CSS для формирования современного адаптивного дизайна сайта. Любая страница состоит из трех условных частей:
\begin{enumerate}
\item Навигационный бар (header), который позволяет легко перемещаться между блоками (модулями) сервиса.
\item Тело страницы (body) - здесь расположен весь основной статический контент и динамический контент.
\item Нижняя часть страницы ('подвал', footer) - в ней отображается вся контактная информация (телефоны, адреса, ссылки) и авторская информация (имена, фамилии, должности)
\end{enumerate}
\subsection{Стартовая страница сервера}

Стартовая страница - это страница, на которую попадает пользователь, когда заходит на сайт или успешно регистрируется в системе / входит в систему под своими логином и паролем. В навигационном баре отображается различное число доступных ссылок на другие модули, в зависимости от того, произведен ли в данный момент вход в систему или нет (есть приватные модули, доступ к которым есть только у авторизованных пользователей).

\begin{figure}% p означает, что нужно выделить для рисунка
	% отдельную страницу; применяется для больших рисунков
	\centering
	%Здесь могла быть ваша лягушка.
	\includegraphics[width=\textwidth]{img/startpage.png}
	\caption{\label{fig:tan-aus}Скриншот 1 стартовой страницы}
\end{figure}

На главной странице возможен переход к модулю "Вход в систему", состоящий из подмодулей "Регистрация" (позволяющий создать нового пользователя в системе) и "Авторизация" (позволяющий существующему пользователю войти в систему). Расположенный далее элемент JQuery Slider позволяет пользователям в форме слайд-шоу наглядно познакомиться с основным функционалом сервиса и его особенностями.

\begin{figure}% p означает, что нужно выделить для рисунка
	% отдельную страницу; применяется для больших рисунков
	\centering
	%Здесь могла быть ваша лягушка.
	\includegraphics[width=\textwidth]{img/startpage3.png}
	\caption{\label{fig:tan-aus}Скриншот 2 стартовой страницы}
\end{figure}

Завершает стартовую страницу блок последних добавленных в базу данных объектов, за которым следует footer страницы.

\subsection{Модуль Места}

С помощью навигационного бара осуществляется переход к модулю 'Места'. В данном разделе осуществляется постраничное отображение всех объектов, хранящихся в базе данных, в порядке убывания их среднего рейтинга. Присутствует возможность перейти по ссылке к детальному описанию всех характеристик объекта. При наведении указателя мыши на объект с помощью средств JavaScript появляется дополнительная графическая и текстовая информация о параметрах объекта. Слева от секции с объектами находится форма контентной фильтрации - она позволяет указывать желательные характеристики объектов и формировать выборку критериев при поиске наиболее подходящих. Многие поля формы допускают множественное выделение. По умолчанию объекты отсортированы по убыванию значения их параметра "Рейтинг"/  , который является вещественным числом от 1.0 до 5.0 и отражает рейтинг заведения по версии сервиса Google. 

\begin{figure}[H]% p означает, что нужно выделить для рисунка
	% отдельную страницу; применяется для больших рисунков
	\centering
	%Здесь могла быть ваша лягушка.
	\includegraphics[width=\textwidth]{img/places1.png}
	\caption{\label{fig:tan-aus}Скриншот модуля Места}
\end{figure}

\subsection{Модуль  Рекомендации}

"Рекомендации"\ - это модуль, полностью отражающий работу коллаборативной фильтрации по поиску пользователей, наиболее похожих по поведению на текущего авторизованного в системе пользователя.

Главной частью этого модуля с динамически формируемой информацией является сгрупированная секция рекомендуемых объектов с основной информацией о них. Также есть возможность перейти по ссылке на более подробное описание объекта, которое хранится в базе данных.

\begin{figure}% p означает, что нужно выделить для рисунка
	% отдельную страницу; применяется для больших рисунков
	\centering
	%Здесь могла быть ваша лягушка.
	\includegraphics[width=\textwidth]{img/rec1.png}
	\caption{\label{fig:tan-aus}Скриншот модуля Рекомендации}
\end{figure}


\begin{figure}[H]% p означает, что нужно выделить для рисунка
	% отдельную страницу; применяется для больших рисунков
	\centering
	%Здесь могла быть ваша лягушка.
	\includegraphics[width=\textwidth]{img/places4.png}
	\caption{\label{fig:tan-aus}Скриншот 1 страницы деталей объекта}
\end{figure}

\begin{figure}[H]% p означает, что нужно выделить для рисунка
	% отдельную страницу; применяется для больших рисунков
	\centering
	%Здесь могла быть ваша лягушка.
	\includegraphics[width=\textwidth]{img/places5.png}
	\caption{\label{fig:tan-aus}Скриншот 2 страницы деталей объекта}
\end{figure}


\subsection{Модуль Личный кабинет}

Личный кабинет - это специальный раздел сайта, доступный только для пользователя, авторизованного в системе. Сервис предоставляет возможность текущему авторизованному пользователю просматривать актуальную информацию о себе (дата регистрации, имя, фамилия, возраст, город и другое), менять её, а также просматривать список объектов, которые отмечены пользователем как понравившиеся. Они являются своеобразными закладками пользователя, а также они используются рекомендательной системой для построения коллаборативной фильтрации.

Модуль Личный кабинет содержит разделы "Профиль"\ и "Любимые места"\ функционал которых описан выше. Скриншот 1 демонстрирует интерфейс раздела "Профиль"\ .Скриншот 2 демонстрирует интерфейс раздела "Любимые места"\, где наглядно отображаются некоторые параметры объектов, которые были идентифициованы пользователем в качестве понравившихся. 

\begin{figure}% p означает, что нужно выделить для рисунка
	% отдельную страницу; применяется для больших рисунков
	\centering
	%Здесь могла быть ваша лягушка.
	\includegraphics[width=\textwidth]{img/profile1.png}
	\caption{\label{fig:tan-aus}Скриншот 1 модуля Личный кабинет}
\end{figure}

\begin{figure}% p означает, что нужно выделить для рисунка
	% отдельную страницу; применяется для больших рисунков
	\centering
	%Здесь могла быть ваша лягушка.
	\includegraphics[width=\textwidth]{img/profile2.png}
	\caption{\label{fig:tan-aus}Скриншот 2 модуля Личный кабинет}
\end{figure}

\section{Реализация сервиса}

Веб-сервис CafeAdviser предоставляет два типа рекомендаций: контентную (по составленному пользовательскому запросу) и коллаборативную (на основе поведенияя пользователя в прошлом и поведении похожих на него пользователей). Для реализации данного сервиса были использованы: среда разработки Sublime Text 2 (легковесный редактор кода с подстветкой синтаксиса), Python версии 3.4, веб-фреймворк Django версии 1.8 (а также набор пакетов предназначенных для работы с ним). Для работы с данными задействована свободная реляционная система управления базами данных MySQL 5.7.

Отличительной особенностью реализации данной работы стало активное взаимодействие со сторонними крупными сервисами, предоставляющими открытые API, в процессе автоматического формирования базы данных. Отдельно нужно упомянуть Open API крупнейшей социальной сети ВКонтакте, созданной Павлом Дуровым в 2006 году. Open API - это интерфейс, который позволяет получать информацию из базы данных vk.com с помощью http-запросов к специальному серверу. Синтаксис запросов и тип возвращаемых ими данных строго определены на стороне самого сервиса. Данные, полученные в результате работы с API VK, используются в алгоритме решения проблемы холодного старта коллаборативной фильтрации.

\subsection{Проблема сбора данных и её решение}

В результате реализации сервиса "CafeAdviser"\ был обнаружен ряд проблем, свойственных подобным системам. Так, проблема сбора данных заключается в том, что все данные о характеристиках и параметрах объектов, которые будут храниться в базе данных системы, невозможно найти, задействовав только один информационный источник. Решением стало формирование собственной базы данных из нескольких крупных источников с помощью открытых API. Это, например, сервисы Google, Yandex, 2GIS. Использовалась и комбинация запросов к API. Под комбинацией запросов здесь понимается цепочка обработки данных, в которой на вход запросу к API одного сервиса подается запрос, а ответ от этого сервиса обрабатывается определенным образом и передается на вход запросу к API уже другого сервиса, получая следующий ответ. Последний ответ в такой цепочке после обработки является результатом всей вычисляющей функции.

Например, у рекомендуемых объектов в данной системе есть такой параметр, как "Район города"\ , который должен храниться в базе данных в качестве строки (string) и представлять из себя привычное название района города (Октябрьский, Кировский, Ленинский и т.д.). Ни один сущестсвующий открытый сервис не предоставляет информацию о районе города по названию заведения или улицы. Для решения данной проблемы был использован метод обратного геотаргетинга: сначала выполняется http-запрос к Google, где в качестве параметра передана строка с поисковым запросом (в данном случае, адрес из параметра объекта "Адрес"\ , данный в произвольном виде), в ответ на http-запрос сервис возвращает JSON-ответ, из которого извлекаются GPS-координаты (широта, долгота) заведения, обрабатываются и передаются параметром в http-запросе к Yandex API. Yandex API отправляет JSON-ответ, из которого можно извелчь название района (в виде строки) и записать в базу данных MySQL. Часть кода функции, реализующей данное поведение, размещена в листинге ниже.

В данном отрывке кода происходит циклический обход всех объектов, полученных в результате запроса к сервису Google, в результате чего параметр "Адрес"\ (строка) объекта, возвращенный в ответе, обрабатывается с помощью функции transliterate, которая переводит каждый кириллический символ строки либо в одиночный латинский символ, либо в соответствующую данному кириллическому символу биграмму. Данная функция находится в модуле вспомогательных функций проекта. Таким образом, вычисленный результат работы функции transliterate передается в качестве параметра в GET-запрос к API сервиса Yandex, который, в свою очередь, отправляет JSON-ответ. 

\begin{ListingEnv}[H]% буква H означает Here, ставим здесь,
	% элементы, которые нежелательно разрывать обычно не ставят
	% посреди страницы: вместо H используется t (top, сверху страницы),
	% или b (bottom) или p (page, на отдельной странице)
	\begin{lstlisting}[language=Python]
	my_key = settings.GOOGLE_PLACES_API_KEY
	google_places = GooglePlaces(my_key)
	query_result = google_places.text_search(query=q, radius=search_radius, language=lang.RUSSIAN, types=[types.TYPE_FOOD, types.TYPE_CAFE, types.TYPE_RESTAURANT])
	for place in query_result.places:
	    place.get_details()
	    if not Cafe.objects.filter(name=place.name).exists():
	        address_list = place.formatted_address.split(',')
	        city1=address_list[2].strip()
	        city2=address_list[1].strip()
	        city3=address_list[3].strip()
	        response = urlopen(u"https://geocode-maps.yandex.ru/1.x/?geocode=" + transliterate(place.formatted_address) + u'&format=json')
	        reader = codecs.getreader("utf-8")
	        data = json.load(reader(response))
	        geolocation = data['response']['GeoObjectCollection']['featureMember'][0]['GeoObject']['Point']['pos']
	        reverse_response = urlopen(u"https://geocode-maps.yandex.ru/1.x/?geocode="+ geolocation + u'&format=json&kind=district')
	        district_dict = json.load(reader(reverse_response))
	        try:
	            district = district_dict['response']['GeoObjectCollection']['featureMember'][0]['GeoObject']['name'] 
	        except IndexError:
	            continue
	\end{lstlisting}
	%следующую команду для генерации подписи можно опустить,
	% хотя рекомендуется все специальные элементы (таблицы, рисунки,
	% листинги) подписывать. Если подпись пропустить, листинг также не получит
	% номера и на него не сошлёшься в будущем
	\caption{Часть кода функции для получения параметра ''Адрес''  объекта с помощью обратного геотаргетинга}
	% далее метка для ссылки:
	\label{list:hwbeauty}
\end{ListingEnv}




\begin{ListingEnv}[H]% буква H означает Here, ставим здесь,
	% элементы, которые нежелательно разрывать обычно не ставят
	% посреди страницы: вместо H используется t (top, сверху страницы),
	% или b (bottom) или p (page, на отдельной странице)
	\begin{lstlisting}[language=Python]

\end{lstlisting}
%следующую команду для генерации подписи можно опустить,
% хотя рекомендуется все специальные элементы (таблицы, рисунки,
% листинги) подписывать. Если подпись пропустить, листинг также не получит
% номера и на него не сошлёшься в будущем
% далее метка для ссылки:
\label{list:hwbeauty}
\end{ListingEnv}

Данное значение затем записывается вместе с остальными характеристиками в базу данных.

\subsection{Контентная фильтрация}

Контентная фильтрация, реализованная в рамках данного сервиса, является не обычным поиском по критериям. Это взвешенный поиск, результатом которого является вычисление значения функции-свертки.

Допустим, есть матрица $C$ размерности $(m \times n)$, где $m$ - количество объектов в системе, а $n$ - количество параметров объекта. Элементы такой матрицы обозначим $c_{i}^{j} \in C, i=1..m , j=1..n, c_{i}^{j} \geq 0$. Каждая строка такой матрицы представляет набор параметров $i$-го объекта.

Также дан вектор параметров $P=\{p_1, ... , p_n\}, p_i \geq 0, i=1..n$, который динамически генерируется по запросу пользователя в ходе работы системы.

Дан вектор ценности параметров $W=\{ w_1, ... , w_n \}, w_i \geq 0, i = 1..n $. Он определяет вес $i$-го параметра.

Определим функции $fit_j(x,y)$ следующим образом ($x \in C, y \in P $ - параметры, $j = 1..n$): 
 
 \[ fit_j(x,y) =
 \begin{cases}
 1       & \quad \text{если } x \text{ попадает в диапазон допустимых значений } y\\
 0      & \quad \text{если } x \text{ не попадает в диапазон допустимых значений} y\\
 \end{cases}
 \]
 
 Результатом называется вектор значений $R$, каждый компонент вектора является вычислением функции-свертки $r$, причем
 $r_i = \sum_{i=1}^{n}(w_i * fit_j(c_{ij}, p_j))$
 
 Таким образом, для вычисления результирующего вектора необходимо лишь подобрать компоненты целочисленного вектора $W$ так, чтобы свертка субъективно давала подходящий результат. 
 
 После подбора и тестирования были получены следующие результаты:
 
 \begin{itemize}
 	\item kindweight = 70   - вклад параметра "Вид заведения"
 	\item priceweight = 30   - вклад параметра "Средний чек"
 	\item areaweight = 15    - вклад параметра "Район заведения"
 	\item cuisineweight = 15   - вклад параметра "Кухни"
 	\item parkingweight = 5    - вклад параметра "Наличие парковки"
 	\item и так далее
 \end{itemize}

Именно таким образом в рамках данной работы была реализована контентная фильтрация, представляющая собой взвешенный поиск по объектам, хранящимся в базе данных на сервере.

\subsection{Коллаборативная фильтрация.}

Коллаборативная фильтрация (англ. collaborative filtering) — это один из методов построения прогнозов (рекомендаций) в рекомендательных системах, использующий известные предпочтения (или, другими словами, оценки) группы пользователей для прогнозирования неизвестных предпочтений другого пользователя. Данный метод в рамках работы был реализован классическим сопсобом с использованием различных метрик для определения расстояния между векторами.

Алгоритм начинается с построения матрицы кросс-табуляции (\textit
{cross-tabulation matrix}) $M$ размерности $n \times m$, где $n$ - количество пользователей в системе, $m$ - количество объектов. Каждый элемент $(i,j)$ такой матрицы показывает, нравится ли $i$-му пользователю $j$-ое заведение. Таким образом, каждый элемент матрицы $M$ формируется по следующему правилу:

\[M_{ij} =
\begin{cases}
1       & \quad \text{если } i \text {-му пользователю нравится объект под номером } j\\
0      & \quad \text{если } i \text{- му пользователю не нравится объект под номером } j\\
\end{cases}
\]

 Нужно  отметить, что отсутствие оценки объекта $(i,j)$ приравнивается ко второму случаю ($i$-му пользователю не нравится объект под номером $j$).
 
 Для матрицы используются данные 80\% пользователей, что уменьшает объем данных для вычислений в условии ограниченных вычислительных ресурсов на сервере. Этот метод сокращения объема вычислений называется \textit
{sampling}. Также производится очистка сигнала от шума (\textit
{noise reduction}), к примеру, из полученных данных перед вычислениями удаляются все нулевые векторы.

\begin{figure}[H]% p означает, что нужно выделить для рисунка
	% отдельную страницу; применяется для больших рисунков
	\centering
	%Здесь могла быть ваша лягушка.
	\includegraphics[width=\textwidth]{img/matrix1.png}
	\caption{\label{fig:tan-aus}Пример небольшой части полученной матрицы кросс-табуляции}
\end{figure} 

C помощью матрицы $M$ можно оценить похожесть пользователей друг на друга, сравнив схожесть строк матрицы с помощью различных метрик.

Транспонируем $M$ и обозначим полученную матрицу как $M^{T}$. Данная матрица представляет уже набор характеристических векторов объектов, хранящихся в базе данных, а не пользователей.
 
\begin{figure}[H]% p означает, что нужно выделить для рисунка
	% отдельную страницу; применяется для больших рисунков
	\centering
	%Здесь могла быть ваша лягушка.
	\includegraphics[width=\textwidth]{img/matrix2.png}
	\caption{\label{fig:tan-aus}Пример небольшой части транспонированной матрицы кросс-табуляции}
\end{figure} 

Далее необходимо установить схожесть строк данных матриц между собой. Для этого используются различные метрики. Экспериментально был выбран метод, сочетающий две распространенные метрики: расстояние Танимото $T$ ($\frac{c}{a+b-c}$) и Евклидово расстояние $E$ ($\sqrt{\sum_{1}^{n} (x_i - y_i)^2} $). Результатом метода является $(T+E)/2$. Значения двух метрик складываются, а затем делятся пополам. Таким образом, мы получаем их среднее значение, которое дает более точный результат, чем каждая из метрик по отдельности.   

\begin{figure}[H]% p означает, что нужно выделить для рисунка
	% отдельную страницу; применяется для больших рисунков
	\centering
	%Здесь могла быть ваша лягушка.
	\includegraphics[width=\textwidth]{img/matrix3.png}
	\caption{\label{fig:tan-aus}Пример небольшой части матрицы коллабораций}
\end{figure} 

\begin{ListingEnv}[H]% буква H означает Here, ставим здесь,
	% элементы, которые нежелательно разрывать обычно не ставят
	% посреди страницы: вместо H используется t (top, сверху страницы),
	% или b (bottom) или p (page, на отдельной странице)
	\begin{lstlisting}[language=Python]
        def create_user_vectors(userrecords):
            statistic = []
            for record in userrecords:
                statistic_user = np.zeros(Cafe.objects.all().order_by("-id")[0].id + 1)
                statistic_user[0] = record.user_id
                for liked_cafe in record.liked.all():
                    statistic_user[liked_cafe.id] = 1
                statistic.append(statistic_user)
            numpy_statistic = np.array(statistic)
            k = 1
            answer = numpy_statistic
            final_answer = []
            for k in range(0, len(answer)-1):
                if (np.count_nonzero(answer[k]) > 1):
                    final_answer.append(answer[k])
            answer = np.array(final_answer)
            np.savetxt("user_vectors.csv", answer.astype(int), fmt='%i', delimiter=",")
            print(answer)
            return answer
	\end{lstlisting}
%следующую команду для генерации подписи можно опустить,
% хотя рекомендуется все специальные элементы (таблицы, рисунки,
% листинги) подписывать. Если подпись пропустить, листинг также не получит
% номера и на него не сошлёшься в будущем
\caption{Функция создания матрицы M}
% далее метка для ссылки:
\label{list:hwbeauty}
\end{ListingEnv}

В результате приведенных вычислений получаем ещё одну матрицу - матрицу коллабораций $C$, содержащей вещественные коэффициенты, в которой элемент матрицы $(i,j)$ показывает насколько объект под номером $i$ похож на объект под номером $j$. 

В приведенных фрагментах кода создаются матрицы $M$ (матрица, характеризующая  пользователей, зарегистрированных в системе) и $C$ (матрица, показывающая схожесть зарегистрированых в системе пользователей между собой). 

Для обработки и хранения матриц, а также расширенной обработки списков используется известный математический пакет NumPy для Python 3. Это расширение языка Python, добавляющее поддержку больших многомерных массивов и матриц, вместе с большой библиотекой высокоуровневых математических функций для операций с этими массивами. Основным объектом NumPy является однородный многомерный массив. Это таблица элементов, всех одного типа, индексированных последовательностями натуральных чисел.
Под многомерностью массива понимается то, что у него может быть несколько измерений или осей. 

\begin{ListingEnv}[H]
    \begin{lstlisting}[language=Python]
        def create_user_matrix():
            userrecords = UserSettings.objects.all()
            cafes = create_user_vectors(userrecords)
            cafe_ids = cafes[:,0]
            num_of_cafes = len(cafes)
            cafe_matrix = np.zeros((num_of_cafes, num_of_cafes), np.float32)
            np.fill_diagonal(cafe_matrix, 0)
            for i in range(0, len(cafes)):
                for j in range(i + 1, len(cafes)):
                    common = 0
                    count_sum = 0
                    for k in range(0, len(cafes[i])):
                        if cafes[i][k] == cafes[j][k]:
                            common = common + 1
                        count_sum = count_sum + math.pow(cafes[i][k] - cafes[j][k], 2)
                check = str(i) + " " + str(j) + " - " + str(common)
                tanimoto_coef = common / (len(cafes[i]) + len(cafes[j]) - common)
                euclid_coef = 1 - (math.sqrt(count_sum) / len(cafes[i]))
                res = str(i) + " " + str(j) + " - " + str(euclid_coef)
                cafe_matrix[i][j] = (tanimoto_coef + euclid_coef) / 2
            return (cafe_ids, cafe_matrix)
    \end{lstlisting}
    \caption{Функция создания матрицы C}
    % далее метка для ссылки:
    \label{list:hwbeauty}
\end{ListingEnv}

\subsection{Проблема холодного старта и её решение}

Под проблемой холодного старта рекомендательных систем понимается высокая разреженность данных, которая появляется либо при старте сервиса, когда количество пользователей, зарегистрированных на нем, близко к нулю, либо сразу после регистрации нового пользователя в системе, когда от него ещё не было никакой активности, а количество обработанных им объектов близко к нулю.

После проведения исследования существующих методик решения этой классической проблемы рекомендательных систем, было решено использовать собственный способ - разбиение всех зарегистрированных пользователей на кластеры (группы) по демографическим и личностным признакам, что, несомненно, влияет на характер, темперамент человека и его предпочтения.

Решение было найдено за пределами существующей системы с помощью скрытого сбора данных из одного из крупнейших сервисов в Российской Федерации - социальной сети "ВКонтакте"\ (www.vk.com), используя API этого ресурса. Выполнение запросов к API выполняется не непосредственно через авторизацию на сервере, а с использованием механизма токенов, то есть необходимо получить ключ доступа access\_token. Cервис "ВКонтакте"\ содержит наибольшее количество открытой информации о пользователях, характеризуя его с разных сторон. Используя API "ВКонтакте"\ (~\autocite{vkapi}) и данные, указанные при регистрации в системе CafeAdviser, стало возможным найти страницу пользователя "ВКонтакте"\ с очень большой долей вероятности, получить необходимые данные, нормализовать их и проанализировать. После разбиение пользователей на заранее выбранное количество кластеров появляется возомжность рекомендовать текущему пользователю какой-то объект из объектов, понравившихся случайно выбранному пользователю в той же демографической группе (кластере). При разбиении пользователей на группы были использованы следующие параметры: наличие высшего образования, наличие военной службы, тип занятости (занятость на работе, студент, временно безработный и т.д.), возраст пользователя, количество подписчиков, музыкальные предпочтения (по жанрам).

Определение наиболее предпочтительного музыкального жанра происходит с помощью использования Наивного Байесовского Классификатора (Naive Bayer Classifier). Это простой вероятностный классификатор, основанный на применении Теоремы Байеса со строгими (наивными) предположениями о независимости.

В зависимости от точной природы вероятностной модели, наивные байесовские классификаторы могут обучаться очень эффективно. Во многих практических приложениях для оценки параметров для наивных байесовых моделей используют метод максимального правдоподобия. Другими словами, можно работать с наивной байесовской моделью, не веря в байесовскую вероятность и не используя байесовские методы.

Несмотря на наивный вид и, несомненно, очень упрощенные условия, наивные байесовские классификаторы часто работают намного лучше во многих сложных практических задачах, подобной определению музыкального жанра по входной строке с перечислением любимых групп и исполнителей.
Достоинством наивного байесовского классификатора является малое количество данных для обучения, необходимых для оценки параметров, требуемых для классификации.
Для обучения использован csv-файл с примерами жанров по возможным ключевым словам.

После нормализации векторов, представляющих данные пользователей из социальной сети "ВКонтакте"\, необходимо произвести их кластеризацию. Данная операция была проведена с использованием алгоритма K-Means (~\autocite{intuitLessons}). Суть алгоритма состоит в выполнении следующей последовательности действий.

\begin{enumerate}
	\item Выбрать количество кластеров k
	, которое является оптимальным для задача (при разработке системы k=5, затем оно должно увеличиваться прямо пропорционально увеличению зарегистрированных пользователей).
	\item Выбросить случайным образом в пространство наших данных k точек (т.н. центроидов).
	\item Для каждой точки набора данных посчитать, к какому центроиду она ближе.
	\item Переместить каждый центроид в центр выборки, которая была отнесена к этому центроиду.
	\item Повторять последние два шага фиксированное число раз (до достижения заранее установленного максимального значения итераций), либо до тех пор пока центроиды не сойдутся (обычно это значит, что их смещение относительно предыдущего положения не превышает какого-то заранее заданного небольшого значения).
\end{enumerate}



Пример части полученных данных, их нормализации и результат итоговой кластеризации приведен на скриншоте ниже.

\begin{figure}[H]% p означает, что нужно выделить для рисунка
	% отдельную страницу; применяется для больших рисунков
	\centering
	%Здесь могла быть ваша лягушка.
	\includegraphics[width=\textwidth]{img/vk1.png}
	\caption{\label{fig:tan-aus}Пример части полученных данных (используются только некоторые параметры), их нормализации и итоговой кластеризации. Разбиение на 5 кластеров.}
\end{figure} 


\Conc

Итогом данной работы стало создание рекомендательного веб-сервиса с использованием новых подходов при поиске ответов на ключевые вопросы подобных систем. Были проведены исследования, позволившие по-новому взглянуть на проблему холодного старта коллаборативных рекомендательных систем и классические проблемы поиска, сбора и обработки данных.

Особенностями системы являются
\begin{itemize}
\item собственная контентная фильтрация, представленная взвешенным поиском, где результатом является вектор, в котором каждый компонент получается путем вычисления значения функции-свертки
\item новое решение проблемы «холодного старта» – скрытый поиск использование открытых данных из крупнейшей социальной сети в Российской Федерации для разбиения на демографические группы (кластеры пользователей) и исследование наилучших методов подобной кластеризации
\item формирование собственной базы данных на сервере путем получения информации из нескольких источников при помощи открытых API крупных сервисов и комбинации этих данных
\end{itemize}

% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
    ,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\appendix
\ifthenelse{\value{worktype} > 1}{%
  \addtocontents{toc}{%
      \protect\renewcommand{\protect\cftchappresnum}{\appendixname\space}%
      \protect\addtolength{\protect\cftchapnumwidth}{\widthof{\appendixname\space{}} - \widthof{Глава }}%
  }%
}{
  \addtocontents{toc}{%
      \protect\renewcommand{\protect\cftsecpresnum}{\appendixname\space}%
      \protect\addtolength{\protect\cftsecnumwidth}{\widthof{\appendixname\space{}}}%
  }%
}

\section{Структура проекта с пояснениями}

\begin{itemize}
	\item CafeAdviser (директория проекта)
	\begin{itemize}
		\item \_\_init.py\_\_
		\item urls.py (роутер проекта)
		\item settings.py (опции, конфигурации и настройки проекта)
		\item wsgi.py
	\end{itemize}
	\item cafe (директория приложения Cafe - непосредственная функциональная часть системы)
	\begin{itemize}
		\item \_\_init.py\_\_
		\item urls.py (роутер приложения)
		\item admin.py (контроллер административной панели)
		\item views.py (контроллеры приложения)
		\item models.py (модели приложения)
		\item forms.py (формы приложения)
		\item apps.py
		\item myutils.py (вспомогательные функции для контроллеров)
		\item tasks.py (функции, предназначенные для циклического выполнения с указанной периодичностью)
		\item migrations (миграции приложения)
		\item templates (шаблоны приложения)
		\item static (статические файлы приложения: css, js, images и другое)
	\end{itemize}
    \item login (директория приложения Login - обработка данных пользователей, регистрация, вход в систему)
    \begin{itemize}
    	\item \_\_init.py\_\_
    	\item urls.py (роутер приложения)
    	\item admin.py (контроллер административной панели)
    	\item views.py (контроллеры приложения)
    	\item models.py (модели приложения)
    	\item forms.py (формы приложения)
    	\item kmeans.py (вспомогательный модуль для реализации алгоритма K-Means (K-средних))
    	\item mysvc.py (вспомогательный модуль для реализации алгоритма )
    	\item migrations (миграции приложения)
    	\item templates (шаблоны приложения)
    	\item static (статические файлы приложения: css, js, images и другое)
    \end{itemize}
    \item requirements.txt (список зависимостей проекта)
    \item trainmusic.csv (csv-файл с данными для обучения музыкальным предпочтениям классификатора Naive Bayer Classifier в кластеризации пользователей с использованием данных из социальной сети ВКонтакте)
    \item cafe\_vectors.csv (csv-файл с данными об оценках, сгруппированных по объектам)
    \item user\_vectors.csv (csv-файл с данными об оценках пользователей)
\end{itemize}

\end{document}
